What is React?
"A JavaScript library for building User Interfaces"

Why use React?
"UI State becomes difficult to handle with Vanilla JavaScript."
"Focus on Business Logic, not on preventing your App from breaking."
"Huge Ecosystem, Active Community, High Performance."

React Alternative
"Angular" "React" "Vue"
"jQuery is more about traversing the dom."

Single Page Applications vs Multipage Applications
"SPA - Only ONE HTML page, Content is re-redered on Client"
"MPA - Multiple HTML Pages, Content is redendered on server"
"If you manage the entire page with JavaScript, you never have to go back to the server to reload the page"
"With SPA, you typically only need ONE ReactDOM.render() call."
"With MPA, You need a ReactDOM.render() call per each component."


Course Outline
--------------
1.  Getting Started
2.  The Basics
3.  Debugging
4.  Styling Components
5.  Components Deep Dive
6.  HTTP Requests
7.  Routing
8.  Forms & Validation
9.  Redux
10. Authentication
11. Intro to Testing
12. Deployment
13. Bonus - Animations, Next Steps, Webpack, NextJS, Etc.


-Getting Started-
-------------------

-- ES6 Refresher

"let - variable values"
"const - constant value"

"arrow functions"
function printMyName(name) {
  console.log(name);
}
printMyName('Anthony');

"As an arrow function"
const printMyName = name => console.log(name);
printMyName('Anthony');


"Exports and Imports"
Inside a JavaScript file, we can import content from another file.

"Import Syntax Examples"
import person from './person.js'

-or-

import{baseData} from './utility'
import{clean} from './utility'

baseData and/or clean imports is for targetting specific data.
It is also known as "named exports".
If using a named export, you must import using the exact name you are exporting.
If using a default export, you can name them whatever you like as long as the file path is correct.


-React Classes-
---------

A class is created with the "class" keyword.
A class can have both "properties" and "methods"
"Properties" are like variables within classes.
"Methods" are like functions within classes.

Classes are kind of like Constructory functions.
Create JavaScript objects with classes with blueprints.
Classes support inheritence.

When creating a class, if it contains any properties,
you must put them inside of a "Constructor Method"

class Example {
  constructor() {
    this.sample = 'Sample';
  }
}


When extending a class to another, you must include the
special "super();" keyword to inherit the classes properties.

class ExampleTwo extends Example {
  constructor() {
    super();
    this.sample2 = 'Another Sample';
  }
}

The "super()" keyword goes inside the constructor function.

When you extend a class to another classes properties, 
you can still hard code in the extended classes properties and override
the inherited properties. Not best practice, or a good habit.

Classes are just "blueprints" for JavaScript "objects" and are 
very comparable to constructor functions, and inheritence is comparable to prototypes.


-Classes Properties Methods-

"Properties" are like "variables attached to classes and objects"
"Methods" are like "functions attached to classes and objects"


-NextJS syntax-
---------------

"Properties"
-ES6-
constructor() {
  this.myProperty = 'value'
}

-ES7-
myProperty = 'value'

When writing your property directly into a class without
the "constructor" function, it will still be compiled behind the scenes into one.
The ES7 syntax allows writing properties easier.


"Methods"
-ES6-
myMethod() {

}

-ES7-
myMethod = () => {

}

Same goes for methods. Although it looks as if you are just,
taking a typical function and writing it as an arrow function(?)

The advantage you have with this syntax is, when you use an arrow function,
you don't have any problems with the "this" keyword.


-The Spread and Rest Operators-
-------------------------------
"..."

The "..." syntax is either a Spread or Rest operator depending on how we use it.

-Spread-
"Used in front of an array"

-Examples-
const newArray = [...oldArray,1,2]

"Also can be used with Objects"
const newObject = {...oldObject, newProp:5}

Used to split up array elements OR object properties.

Spread is used to take an "array" and extract the values within it,
creating a new "array" with copies of those values, and add in new values.

Must use the "spread operator" to make a "copy" of an array to manipulate it,
because in React, state is immutable and cannot be changed.


-Rest-
"Used in a function arguements list"

Used to "merge" a list of "function arguements"
into an array.

-Examples-
function sortArgs(...args) {
  return args.sort()
}



-Destructuring-

"Destructuring" allows you to easily extract array elements,
or object properties and store them in variables.

-Array Destructuring-
[a,b] = ['Hello, 'Max']
console.log(a) // Hello
console.log(b) // Max

Using the syntax above, we can assign the values "Hello" and "Max" to variables.
It looks like we are creating a new Array but we are not, we are assigning variables to an arrays values.

Another example of "Array Destructuring might look something like,

const numbers = [1, 2, 3];
[num1, , num3] = numbers;
console.log(num1, num3); // 1, 3

You can pull are items in varied orders by using a space in one values position to skip it.


-Object Destructuring-
{name} = {name:'Max', age:28}
console.log(name) // Max
console.log(age) // undefined

In "Array Destructuring", the order defines which property we take.
Whereas in "Object Destructuring" it's the property name.

So the syntax: "{name}" targets the name property in the above object, and pulls out it's value.
This is why "age" returns undefined, as we are only pulling the "name" property out of the object.


-Reference and Primitive Types refresher-

-Primitive types-
"Numbers, Strings, Booleans" these are "Primitive Types"
Whenever you reassign or store a variable inside another variable, it will copy the value.

-Reference Types-
"Objects, Arrays" these are "Reference Types"
When you reassign an object variable to another variable, it still stores it's values,
but it does "NOT" copy it's values.

ObjectA will be stored inside memory, whereas object B will store a "POINTER", that is pointing to object "A"

-Examples-
------------------------------
const person = {
  name: "Anthony"
};

const secondPerson = person;

person.name = "Vincent";

console.log(secondPerson;) // name: "Vincent"
------------------------------

This is important in React as it can cause unexpected behaviors,
if you "copy" arrays and objects like this, because you may manipulate one object in one place,
and accidently manipulate another usage of the same object somewhere else in the application.

This is where the "spread operator" becomes handy and important,
because with the "spread operator" you are literally making a new "copy",
without manipulating the original values.

------------------------------
const person = {
  name: 'Anthony'
};

const secondPerson = {
  ...person;
}

person.name = 'Vincent';

console.log(secondPerson); // name: "Anthony"
-------------------------------

The "name" property remains unchanged, as "secondPerson" it it's own copy first, of the original values.
instead of storing a "pointer", pointing to the "location" of the object.

It's important to remember, "Objects" and "Arrays" are "Reference Types".
And when you reassign them, you are copying the "Pointer" not the value.


-Array Functions Refresher-

Each one of these array functions take an arrow function as a parameter.
The function then gets executed on each item in the array as it is iterated.

-Examples-
-------------------
const numbers = [1, 2, 3];

const doubleNumArray = numbers.map((num) => {
  return num*2;
});

console.log(numbers); // [1, 2, 3]
console.log(doubleNumArray) // [2, 4, 6]


-REACT BASICS-

"Build Workflow"
----------------

Why?
"Optimize Code"
  When we build and deploy our app, we want our code to be optimized and as small as possible.
  This in turn boosts the performance of our app.

"Next-Gen JavaScript"
  Makes writing our code much easier and more efficient.
  Also is the standard for writing React applications.
  The result is a codebase that is "leaner, easier to read, faster, and less error prone"

"Be more productive"
  CSS auto prefixing, helps with adding cross-browser support code to our CSS.

How?
  "Dependency Management Tool"
    NPM, Node Package Manager.
    NPM is standard.

  "Bundler"
    Webpack
    Bundle together modules or split up files.

  "Compiler"
    Babel + Presets
      Compile your ES6/ES7 JavaScript code down for browser support.

  "Development Server"


-Create React App-
To install, you install it "globally" with "npm"
Must have "Node.js" installed.

"npm install -g create-react-app"

To start a React application, run "create-react-app" followed by the app "name"

"create-react-app myReactApp"

Once the "react app" is made, "cd" into that file and run "npm start" to start the "development server".

// Must leave the Terminal tab running the Local Dev Server open-


-Understanding React folder Structure-

Inside the root folder is the package.json file which shows all of your app dependencies.
It also has scripts, which can be run using NPM.

The public folder, is the folder that gets served by the web server.
It only holds the files we can edit.
The script files are edited in the "src" folder.
In the public folder is a single "index.html" This is the only html file we will use.
You will never create additional HTML files, unless you are working on a Multi-Page Application.
In which case will require a seperate type of build tools.

The src folder is where we write our actual react app.

Included is an image file we can remove.
There is also an "app.css" file, where you can remove all the global styling in it.
Included as well is an "index.css" file with a global reset styling that can be left there.
The "app.test.js" file allows us to create "Unit Testing"

In the "app.js" file, there is an "App" component.
This is where we will include all of our other components,
building our app through this one "app" compoenent.

You can create many components, and render them individually elsewhere, but it is "not best practice"

In the "App" component, all other components get nested into each other to build out your app.

-Component Structure-

The way to create a component is to use the "class" syntax,
followed by the component "name", and optionally you can add the extends keyword,
and inherit other properties from other components.
In the included App.js file, there is an "App" component.

class App extends Component {

}

The "Class" keyword initializes the class, or component,
Follow by the name of the component, in this case "App"
and it also is extending, or inheriting properties from "Component"
"Component" is a an object, or class, that is being "IMPORTED" from the "react library"

// There are OTHER ways to create components
// Will learn that later on..

The "App" component has ONE method, the "render()" method.
It NEEDS to have that, because react will call this method, to render something to the screen.

There's one important job, every react component HAS to do...

// It MUST return some sort of HTML code
// So that it can be rendered to the DOM
// And obviously to the screen

// ALL COMPONENTS MUST DO THIS

At the bottom of the file is an export set to default.

"export default App"

This export simply means, anytime this file is imported,
It is just importing the "App" component by default.

You may also encounter some files with the ".jsx" extension instead of the ".js" extension.


-Understanding JSX-

"React.createElement()" is a react method that takes at least "THREE" arguments,

1. Element we want to render to the DOM.
2. The second arguement, is the "configuration"
3. Any amount of children, or what's nested inside the element.

-Example-
---------

return React.createElement('div', null, 'h1', 'Hi, I\'m a React App!);
---------

Although, the "h1" is not being rendered as an HTML element,
Infact, it's actually being rendered as text.

If you want to create additional elements within your React.createElement()
You will need to add another createElement method like so,

return React.createElement(
  'div',
  null,
  React.createElement(
    'h1',
    null,
    'Hi, I\'m a React App!'
  );
);


As for the configuration part, where it says null,
That is where you can do things such as add a class to your HTML elements.

return React.createElement(
  'div',
  {classNam: "App"}
)

In the null space, adding curly braces, and within stating your class name, will add it to your element.

// Above is not how you want to write your components.
// Above is just a demonstration of what your JSX actually compiles to.
// It's recommended, and BEST to stick with writing with JSX syntax.
// Although JSX may look like HTML, from looking at what it compiles to above,
// It is obvious, and important to understand that it is NOT HTML. It is actually JavaScript.


-JSX Restrictions-

