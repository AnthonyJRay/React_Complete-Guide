What is React?
"A JavaScript library for building User Interfaces"

Why use React?
"UI State becomes difficult to handle with Vanilla JavaScript."
"Focus on Business Logic, not on preventing your App from breaking."
"Huge Ecosystem, Active Community, High Performance."

React Alternative
"Angular" "React" "Vue"
"jQuery is more about traversing the dom."

Single Page Applications vs Multipage Applications
"SPA - Only ONE HTML page, Content is re-redered on Client"
"MPA - Multiple HTML Pages, Content is redendered on server"
"If you manage the entire page with JavaScript, you never have to go back to the server to reload the page"
"With SPA, you typically only need ONE ReactDOM.render() call."
"With MPA, You need a ReactDOM.render() call per each component."


Course Outline
--------------
1.  Getting Started
2.  The Basics
3.  Debugging
4.  Styling Components
5.  Components Deep Dive
6.  HTTP Requests
7.  Routing
8.  Forms & Validation
9.  Redux
10. Authentication
11. Intro to Testing
12. Deployment
13. Bonus - Animations, Next Steps, Webpack, NextJS, Etc.


-Getting Started-
-------------------

-- ES6 Refresher

"let - variable values"
"const - constant value"

"arrow functions"
function printMyName(name) {
  console.log(name);
}
printMyName('Anthony');

"As an arrow function"
const printMyName = name => console.log(name);
printMyName('Anthony');


"Exports and Imports"
Inside a JavaScript file, we can import content from another file.

"Import Syntax Examples"
import person from './person.js'

-or-

import{baseData} from './utility'
import{clean} from './utility'

baseData and/or clean imports is for targetting specific data.
It is also known as "named exports".
If using a named export, you must import using the exact name you are exporting.
If using a default export, you can name them whatever you like as long as the file path is correct.


-React Classes-
---------

A class is created with the "class" keyword.
A class can have both "properties" and "methods"
"Properties" are like variables within classes.
"Methods" are like functions within classes.

Classes are kind of like Constructory functions.
Create JavaScript objects with classes with blueprints.
Classes support inheritence.

When creating a class, if it contains any properties,
you must put them inside of a "Constructor Method"

class Example {
  constructor() {
    this.sample = 'Sample';
  }
}


When extending a class to another, you must include the
special "super();" keyword to inherit the classes properties.

class ExampleTwo extends Example {
  constructor() {
    super();
    this.sample2 = 'Another Sample';
  }
}

The "super()" keyword goes inside the constructor function.

When you extend a class to another classes properties, 
you can still hard code in the extended classes properties and override
the inherited properties. Not best practice, or a good habit.

Classes are just "blueprints" for JavaScript "objects" and are 
very comparable to constructor functions, and inheritence is comparable to prototypes.


-Classes Properties Methods-

"Properties" are like "variables attached to classes and objects"
"Methods" are like "functions attached to classes and objects"


-NextJS syntax-
---------------

"Properties"
-ES6-
constructor() {
  this.myProperty = 'value'
}

-ES7-
myProperty = 'value'

When writing your property directly into a class without
the "constructor" function, it will still be compiled behind the scenes into one.
The ES7 syntax allows writing properties easier.


"Methods"
-ES6-
myMethod() {

}

-ES7-
myMethod = () => {

}

Same goes for methods. Although it looks as if you are just,
taking a typical function and writing it as an arrow function(?)

The advantage you have with this syntax is, when you use an arrow function,
you don't have any problems with the "this" keyword.


-The Spread and Rest Operators-
-------------------------------
"..."

The "..." syntax is either a Spread or Rest operator depending on how we use it.

-Spread-
"Used in front of an array"

-Examples-
const newArray = [...oldArray,1,2]

"Also can be used with Objects"
const newObject = {...oldObject, newProp:5}

Used to split up array elements OR object properties.

Spread is used to take an "array" and extract the values within it,
creating a new "array" with copies of those values, and add in new values.

Must use the "spread operator" to make a "copy" of an array to manipulate it,
because in React, state is immutable and cannot be changed.


-Rest-
"Used in a function arguements list"

Used to "merge" a list of "function arguements"
into an array.

-Examples-
function sortArgs(...args) {
  return args.sort()
}



-Destructuring-

"Destructuring" allows you to easily extract array elements,
or object properties and store them in variables.

-Array Destructuring-
[a,b] = ['Hello, 'Max']
console.log(a) // Hello
console.log(b) // Max

Using the syntax above, we can assign the values "Hello" and "Max" to variables.
It looks like we are creating a new Array but we are not, we are assigning variables to an arrays values.

Another example of "Array Destructuring might look something like,

const numbers = [1, 2, 3];
[num1, , num3] = numbers;
console.log(num1, num3); // 1, 3

You can pull are items in varied orders by using a space in one values position to skip it.


-Object Destructuring-
{name} = {name:'Max', age:28}
console.log(name) // Max
console.log(age) // undefined

In "Array Destructuring", the order defines which property we take.
Whereas in "Object Destructuring" it's the property name.

So the syntax: "{name}" targets the name property in the above object, and pulls out it's value.
This is why "age" returns undefined, as we are only pulling the "name" property out of the object.


-Reference and Primitive Types refresher-

-Primitive types-
"Numbers, Strings, Booleans" these are "Primitive Types"
Whenever you reassign or store a variable inside another variable, it will copy the value.

-Reference Types-
"Objects, Arrays" these are "Reference Types"
When you reassign an object variable to another variable, it still stores it's values,
but it does "NOT" copy it's values.

ObjectA will be stored inside memory, whereas object B will store a "POINTER", that is pointing to object "A"

-Examples-
------------------------------
const person = {
  name: "Anthony"
};

const secondPerson = person;

person.name = "Vincent";

console.log(secondPerson;) // name: "Vincent"
------------------------------

This is important in React as it can cause unexpected behaviors,
if you "copy" arrays and objects like this, because you may manipulate one object in one place,
and accidently manipulate another usage of the same object somewhere else in the application.

This is where the "spread operator" becomes handy and important,
because with the "spread operator" you are literally making a new "copy",
without manipulating the original values.

------------------------------
const person = {
  name: 'Anthony'
};

const secondPerson = {
  ...person;
}

person.name = 'Vincent';

console.log(secondPerson); // name: "Anthony"
-------------------------------

The "name" property remains unchanged, as "secondPerson" it it's own copy first, of the original values.
instead of storing a "pointer", pointing to the "location" of the object.

It's important to remember, "Objects" and "Arrays" are "Reference Types".
And when you reassign them, you are copying the "Pointer" not the value.


-Array Functions Refresher-

Each one of these array functions take an arrow function as a parameter.
The function then gets executed on each item in the array as it is iterated.

-Examples-
-------------------
const numbers = [1, 2, 3];

const doubleNumArray = numbers.map((num) => {
  return num*2;
});

console.log(numbers); // [1, 2, 3]
console.log(doubleNumArray) // [2, 4, 6]


-REACT BASICS-

"Build Workflow"
----------------

Why?
"Optimize Code"
  When we build and deploy our app, we want our code to be optimized and as small as possible.
  This in turn boosts the performance of our app.

"Next-Gen JavaScript"
  Makes writing our code much easier and more efficient.
  Also is the standard for writing React applications.
  The result is a codebase that is "leaner, easier to read, faster, and less error prone"

"Be more productive"
  CSS auto prefixing, helps with adding cross-browser support code to our CSS.

How?
  "Dependency Management Tool"
    NPM, Node Package Manager.
    NPM is standard.

  "Bundler"
    Webpack
    Bundle together modules or split up files.

  "Compiler"
    Babel + Presets
      Compile your ES6/ES7 JavaScript code down for browser support.

  "Development Server"


-Create React App-
To install, you install it "globally" with "npm"
Must have "Node.js" installed.

"npm install -g create-react-app"

To start a React application, run "create-react-app" followed by the app "name"

"create-react-app myReactApp"

Once the "react app" is made, "cd" into that file and run "npm start" to start the "development server".

// Must leave the Terminal tab running the Local Dev Server open-


-Understanding React folder Structure-

Inside the root folder is the package.json file which shows all of your app dependencies.
It also has scripts, which can be run using NPM.

The public folder, is the folder that gets served by the web server.
It only holds the files we can edit.
The script files are edited in the "src" folder.
In the public folder is a single "index.html" This is the only html file we will use.
You will never create additional HTML files, unless you are working on a Multi-Page Application.
In which case will require a seperate type of build tools.

The src folder is where we write our actual react app.

Included is an image file we can remove.
There is also an "app.css" file, where you can remove all the global styling in it.
Included as well is an "index.css" file with a global reset styling that can be left there.
The "app.test.js" file allows us to create "Unit Testing"

In the "app.js" file, there is an "App" component.
This is where we will include all of our other components,
building our app through this one "app" compoenent.

You can create many components, and render them individually elsewhere, but it is "not best practice"

In the "App" component, all other components get nested into each other to build out your app.

-Component Structure-

The way to create a component is to use the "class" syntax,
followed by the component "name", and optionally you can add the extends keyword,
and inherit other properties from other components.
In the included App.js file, there is an "App" component.

class App extends Component {

}

The "Class" keyword initializes the class, or component,
Follow by the name of the component, in this case "App"
and it also is extending, or inheriting properties from "Component"
"Component" is a an object, or class, that is being "IMPORTED" from the "react library"

// There are OTHER ways to create components
// Will learn that later on..

The "App" component has ONE method, the "render()" method.
It NEEDS to have that, because react will call this method, to render something to the screen.

There's one important job, every react component HAS to do...

// It MUST return some sort of HTML code
// So that it can be rendered to the DOM
// And obviously to the screen

// ALL COMPONENTS MUST DO THIS

At the bottom of the file is an export set to default.

"export default App"

This export simply means, anytime this file is imported,
It is just importing the "App" component by default.

You may also encounter some files with the ".jsx" extension instead of the ".js" extension.


-Understanding JSX-

"React.createElement()" is a react method that takes at least "THREE" arguments,

1. Element we want to render to the DOM.
2. The second arguement, is the "configuration"
3. Any amount of children, or what's nested inside the element.

-Example-
---------

return React.createElement('div', null, 'h1', 'Hi, I\'m a React App!);
---------

Although, the "h1" is not being rendered as an HTML element,
Infact, it's actually being rendered as text.

If you want to create additional elements within your React.createElement()
You will need to add another createElement method like so,

return React.createElement(
  'div',
  null,
  React.createElement(
    'h1',
    null,
    'Hi, I\'m a React App!'
  );
);


As for the configuration part, where it says null,
That is where you can do things such as add a class to your HTML elements.

return React.createElement(
  'div',
  {classNam: "App"}
)

In the null space, adding curly braces, and within stating your class name, will add it to your element.

// Above is not how you want to write your components.
// Above is just a demonstration of what your JSX actually compiles to.
// It's recommended, and BEST to stick with writing with JSX syntax.
// Although JSX may look like HTML, from looking at what it compiles to above,
// It is obvious, and important to understand that it is NOT HTML. It is actually JavaScript.


-JSX Restrictions-

Even though "JSX" looks like and "HTML", and now we know that it is actually "JavaScript",
there are some words that cannot be used like in regular "HTML".

"Class" for example, is the attribute you might use to add a "class" to an "HTML" element.
But in "JavaScript" "class" is a reserved word.

Instead, in "JSX", you must use the "className" syntax to assign an "element" a "class".

-Creating a Functional Component-

When creating new folders for your new component files in the "src" folder,
it's standard practice to always start the names of those files with a uppercase, or capital.
Within that folder, should exist the corresponding js file for your component with the matching name of the folder.

-Most of the time-, the way you "should" write a "component" is as a "functional component"
The "class components" become more useful when we start learning about "State"
-For- now, most "components" should be written as a "functional component".

// In it's simplest form, a Component, is just a JavaScript function,
// That returns, some JSX.

To create a simple "Functional Component"

-Example-
-----------------------------
import React from 'react';

const person = () => {
  return <p>I'm a person!</p>
}

export default person
------------------------------

Above, is just a normal "Arrow Function" returning some "JSX".
You must remember to "import" react at the top, so that it will compile your "JSX" into JavaScript to work.
Also, remember to export your component.

Then all you would have to do, is "import" your component in the "App.js" file, starting with a capitalized character on the import name.

"import Person from './Person/Person';"

You can leave out the file extension on your import, as the build tools will know for you.

Once imported, you can add your component a couple of ways into your render method...

<Person> </Person>
-or-
<Person />

Either syntax works. It depends on if your component is written to take in nested components.

The reason for the capitalize starting character, is becaause,
lowercase characters are reserved for HTML tags. Therefore, in order to differenciate between,
and HTML tag and a react component, component names must start with an uppercase character.


-Components and Reusable Components-

So what is the advantages of components?
"Components" are useful because we can focus our code in each file, and helps keep it more maintainable.
They can also be "reuseable" and "configurable"

-----------------------------
const person = () => {
  return <p>I'm a Person!</p>
};
-----------------------------

The component above, is currently static. Each time you use this component, the same type of information will be used.

You want your components to be "Dynamic" and to update it's information based on it's current "State"

-Simple Example-

  return <p> I'm a Person and I am {Math.floor(Math.random() *30)} years old </p>

  From the above example, you'll notice we added some JavaScript inside of our JSX.
  In order for React to read it like JavaScript instead of plain text,
  "You must wrap it in a set of curly braces"

  Inside the curly braces, you can not add classes.
  What you can add, is "short" "single-line" "JavaScript Expressions"
  You could also call a function, and that function also call some more complex functions.


-Working with Props-

For normal "HTML/JSX" elements, we can pass "Attributes" like "className"

Inside our "Component" JSX tags, we can add custom attributes called "props"
In order for your component to accept props, You must pass "Props" as an arguement.

-Understanding the Children Attribute-
"Using content that is not passed as an attribute, but passed between the opening and closing tags of a component"

"props.children"

Children is a reserved name.
It refers it any elements, between the opening and closing tag of a component.


-Understanding and Using State-

When creating "Variables" inside of a "Class", 
you don't need to use a variable keyword. Started
Such as: "Var" "Let" "Const"

This only works in Components "Extending" Components.

Where "PROPS" are set and passed from "OUTSIDE" the component,
"STATE" is managed "INSIDE" the component.

-REMEMBER-
"STATE" is only accessible from "CLASS" based components "EXTENDING" to Component.

There is a way to manage state in functional components with "React Hooks". Will cover later in course.


Although, You should use "functional components" as often as possible,
because you should use "STATE" with care.

Having in state in all of your components, can make your app run unpredictably quickly.
and can also make for an app that is hard to maintain.

We initialize "state" by assigning it a "value". 
The "value" being a "JavaScript Object".

-------------
state = {

}
-------------

The special thing about "State" is that it can be changed.
If it changes, it will let React re-render the DOM or update the DOM.


-Course Notes-

"props" and "state" are CORE concepts of React. Actually,
only changes in "props" and/or "state" trigger React to
re-render your components and potentially update the DOM
in the browser.

"Props" - Allow you to pass data from a parent (wrapping)
component to a child (embedded) component.


-Example-

---------------------------------

"AllPosts Component"

const posts = () => {
  return (
    <div>
      <Post title="My first Post" />
    </div>
  );
}

----------------------------------

Here, "title" is the custom property ("prop")
set up on the custom "Post" component. We basically replicate
the default HTML attribute behaviour we already know

eg (<input type="text">
informs the browser about how to handle that input.)

"Post Component"

------------------------------

const post = (props) => {
  return (
    <div>
      <h1>{props.title}</h1>
    </div>
  );
}

-------------------------------

The "Post" component receives the "props" argument. 
You can of course name this argument whatever you want -
it's your function definition, React doesn't care!

But React will pass one argument to your component function =>
An object, which contains all properties you set up on <Post .... />

"{props.title}" then dynamically outputs the "title" property,
of the "props" object - which is available since we set the "title" property inside "AllPosts" component(see above).


-State-

Whilst props allow you to pass data down the component tree,
(and hence trigger an UI update), "state" is used to change the component, state, from within.
Changes to state also trigger an UI update.

-Example-
---------------------------------------------

class NewPost extends Component { // state can only be accessed in class-based components!
    state = {
      counter: 1
    };

    render () { // Needs to be implemented in class-based components! Must return some JSX!
      return (
        <div>{this.state.counter}</div>
      );
    }
 }
----------------------------------------------

Here, the "NewPost" component contains "state".
Only class-based components can define and use "state".
You can also pass the "state" down to functional components,
but these then can't directly edit it.

"State" simply is a property of the component class,
you have to call it "state" though - the name isn't optional.
You can then access it via "this.state" in your class JSX code (which you return in the required "render()" method).

Whenever "state" changes, the component will re-render and reflect the new state.
The difference to "props" is, that this happens within one and the same component -
you don't receive new data ("props") from outside!


-Handling Events with Methods-

"<button onClick={}></button>"

Using "onClick" you then assign as a "value",
the code you want to run, upon a click.

You can use curly braces "{}"
To then insert some "Dynamic" code.

-Typically- you'll want to "execute" a "function",
of your "class". A so-called "Method".

There is a convention, to give it's name like the following -

"switchNameHandler"

The "switchName" part is up to you,
but you typically use "Handler" at the end.
To indicate, that this is a "method" you're not "actively"
calling... but you're assigning as an "Event Handler"

It is not required to follow this pattern, 
but it is "Good Practice" to follow this naming convention.
eg "buttonNameHandler", "clickMeHandler".

Now, you'll want to turn "switchNameHandler" into a function.

-----------------------------
switchNameHandler = () => {

}
-----------------------------

If we assign a "function" to the "switchNameHandler",
it basically becomes a method.

Because it still exists inside the "class-based component",
it is kind of a "Property"

But a "property" that holds a "function" for which can be "executed".

From here, inside the "switchNameHandler" arrow function,
you can now "edit" your "state".


"<button onClick={this.switchNameHandler}> I'm a Switch! </button>

To add the "switchNameHandler" to your button, simply add
the "this" keyword, followed by the name of the "handler".

Remember, "this" is just pointing to our "class" component.

Also, don't add the parenthesis "()" to the end of the "handler",
or else it will run the function "immediately" upon rendering.

There are many other "events" you can listen for besides "onClick"
Check the React documentation for more such as,

"onCopy"
"onPaste"
"onCut"


-Manipulating the State-

Now with the "Handler" in place, we can start to manipulate the state.

-------------------------------------------
switchNameHandler = () => {
  this.state.persons[0].name = "New Name";
}
-------------------------------------------
// You CANNOT directly manipulate the state like this!

Instead, use a special "Method" React gives you.

-setState-

The "setState" method, comes from the React library,
through extending the class component to "Component"

-------------------------------------------
switchNameHandler = () => {
  this.setState()
}
-------------------------------------------

This is a "method" that allows us to "update" the "state"
property.

That way, React will know about this "update", 
and will update the "DOM".

"setState" takes an "Object" as an arguement, and
it will "merge" whatever we define inside the "Object",
with our existing "state".

There aren't many ways, that lead React to "update" the DOM,
changing "State" and "Props".

Now, with "Props", you can use "State" in "Functional" components,
but you will need to use "React Hooks" to achieve this.


-Using useState Hook for State Manipulation-

In the release of version 16.8, "React Hooks" were released.
"React Hooks" allow us to manage "State" in "Functional" components.

// Even though it is now possible to manage State in -
// Functional Componenents, it is still best to stick with
// the traditional convention of managing state in your
// Class-based components.

Most likely, if you are working on a React team, you will be,
working with an application that uses the traditional syntax.
"React Hooks" is still new, and hasn't yet become the
traditional method for managing state.

"React Hooks" is really just a list of "Functions" of which, 
you can use in your "Functional Components".

To use "React Hooks" you must "import" them, just like "Components".

To import "React Hooks" you use the "useState" keyword.

"import React, { useState }, from 'react';"

All "React Hooks" start with the "useState" syntax.

"useState" is the MOST important "React Hook"
"useState" allows us to use state, in a "functional component".

To use "useState", you call it, like a function.
Into the "useState" function parameters, you pass in,
the "initial state".

-Example-
// Taking our "State" from our class-based component from earlier
// and turning into a React Hook

class
state = {
  persons: [
    { name: 'Anthony', age: 30 },
    { name: 'Debra', age: 29 },
    { name: 'Vincent', age: 1 },
    { name: 'Max', age: 28 },
    { name: 'Manu', age: 29 }
  ]
}

-to-

const App = props => {
 const stateArr = useState({
    persons: [
      { name: 'Anthony', age: 30 },
      { name: 'Debra', age: 29 },
      { name: 'Vincent', age: 1 },
      { name: 'Max', age: 28 },
      { name: 'Manu', age: 29 }
    ]
  });
}

"What exactly does useState do?"

"useState" returns and "array" with exactly "two" elements,
and "ALWAYS" two elements.

- The "first" thing we get back will always be our "CURRENT" state,
the "CURRENT" "initial state", as well as the "updated" changes, if there are any.

- The "second" element we get back is a "function" that allows us to -
"update" our "state". This allows "React" to be aware of it, and -
"re-render" the "component".

Which is the idea, and which is the same thing that happens with "State' -
in "Class-Based Components".

-Array Destructuring-

Adding a pair of square brackets "[]" to the "left" side of the "equal sign",
which allows you to pull elements out of the array you get back from the "equal sign"

Now you just replace "this.state" with the "personsState", because,
we are using a "functional" component instead of a class-based component,
the "this" keyword will not work.
"This" only pertains to a "class-based component".

When using "React Hooks", the "function" we get back as our "second element",
with "useState" that allows us to update or modify our "state",
Does "NOT" "merge" the "new state" with the "old state".
Instead, it "overwrites" the "old state" with the "new state".

Any data from the old state you want to keep, must be manually included.

The better, more elegant way to manually add existing state properties,
is to use "useState" "multiple" times.

Where as in "Class-Based" components, you only have "one" state property,
and "this.setState" automatically "merges" changes with the old state.


-Stateless vs Stateful Components-

No matter which type of component you use, // Class-based or Functional
you can differinciate your components into,
"Stateful" and "Stateless" Components.

A "Stateful" Component, is a component that manages "State".
A "Stateless" Component, is a component that has no "State Management".

It is a good practice to create as many "Stateless" Components, // Dumb Components
as possible, and as few "Stateful" Components as possible.      // Smart Components/Presentational Components
Yu were only want a couple "Stateful" Components.
"Of course this depends on the size of your app."

-Passing Method References Between Components-

You can pass a "reference", of a "function" in the main "App" component,
as a "property" to a "component" and use the function, from inside another component file.

You can also pass "Methods" as "props". So that you can call a "Method",
which might change the "state" from another "component" that doesn't have access to the state.


-Adding Two Way Binding-

you can run into problems when, Adding a "value" for example, on an "input" tag,
without having an "onChange" or some way to change it.

This is "binding" the "value" to a "property" without allowing yourself to react to changes.
This will lock your input down, and you wouldn't be able to add anything into the "input" field,
because we aren't allowing it to react to changes.


-Adding Styling with Stylesheets-

There are 2 ways to add styling to your component(s).

-First-
You can create a corresponding a CSS file in the same folder.

e.g:

-> src
  -> Person 
      Person.js
      Person.css

BUT, any CSS that is saved in the "Person.css" file,
is NOT "scoped" to the "Person.js" file.

It is "Global" css code.

// Remember to import your css file into the main app.js
// remember to use className to assign a JSX element a css class.

-Working with inline Styles-

There is nothing wrong with using "css classes" and "imports" to style your component.
But you'll often find that in React apps, you design your CSS using JavaScript.

Inside your "render()" method, create an Object

eg..

const style = {
  backgroundCOlor: 'white',
  font: 'inherit',
  border: '1x solid blue',
  padding: '8px
};

"Remember", you are writing JavaScript, don't forget to "Camel Case".
Also remember to wrap your values with quotations.

To use your newly created "Object" styles, simply add,
a "style={}" tag as an "attribute" to an element.

set the "value" to the name of your style object.

"style={style}"

There are many restrictions to styling with inline styles.
Such as, hover effects. There are many ways around these restrictions.
Learn more later...

You can use a css file, but all those styles are "global",
and would effect everything under those styles.
eg.

button {

}


-or- 

You use "inline" styling, and then the CSS is "scoped" to each JavaScript component or element.
But there are some "restrictions".


" Rendering Lists and Conditional Statements"

You can wrap content/element in a single pair of curly braces ( {} ),
and turn it into a JavaScript Expression.

Inside there, you can start some Conditional Statements.
You also have access to any JavaScript property, and turn it into a Ternary Expression.
You can "NOT" use a traditional "If else" statement, it will now work.
Instead you must use the "ternary" syntax.

{ ifThisMethodReturnsTrue ?
<div>
  <HiddenComponent />
  <HiddenComponent />
  <HiddenComponent />
</div> : null
}

The above example is a quick demonstration of how you can use the "Ternary Operator".
"ifThisMethodReturnsTrue" Then render the follow code.
"Else" it is "null" and will render nothing.
// There is a better way to add Conditionals, read down.

Remember, to add a property in your "State" that would initialize "False".

eg. "showComponent: false"

Then create a new method, for instance, "ifThisMethodReturnsTrue".

Ternary Operator
If this is true ? Return This Code : or Else do this


Method Example

togglePersonsHandler = () => {
  const doesShow = this.state.showPersons
  this.setState({ showPersons: !doesShow })
}

The way that this method works is,
Once executed, it will set the "doesShow" variable to the current state. e.g "showPersons".
Then, it sets showPersons in the state, not equal to doesShow.

If "doesShow" is false, it will set "showPersons" to "true".
If "doesShow" is "true", it will set "showPersons" to "false".


"Handling Dynamic Content, the JavaScript way"

If you remember, Everything we are doing in React, is just JavaScript.

There is a way to use a traditional if else statement.

Inside the "Render" method, you can write plain JavaScript code

let persons = null; // Initialize persons to null

if ( this.state.showPersons ) { // If persons is true
  Some JSX code here            // Render this JSX
}

Since there will be a state change, when the button is clicked,
React will re-render the DOM, and update the State.

By initializing persons to "null", it will display nothing,
because it will only render the JSX if "true".
It becomes "true" when the button is clicked.
Because of the method we passed into the onClick attribute.

Writing your conditionals this way helps to keep your code CLEAN.
Keeping the JSX structure the same, and "outsourcing" specific conditionals.
Keeps conditionals in one area(?).



"Outputting Lists"

In the current version of our code, we have our list of "Persons",
hardcoded to render. This doesn't create true DYNAMIC content.

A better method is using the .map() method on our array of "Persons" in our "State".

<div>
  {this.state.persons.map(person => {
    return <Person 
    name={person.name}
    age={person.age} />
  })}
</div>

This syntax allows us to take our "Persons" "State" and "map()" over it,
returning something for each item in our array.

In this case, we are returning a "<Person />" tag, to match our component.
And adding in the same information as before,
with the "name" property being set to the "person.name" and so on.

our "Person" argument arrow function, can be named whatever you would like.
Because we are returning an array of "Persons", "Person" is a fitting description for this example.

In these few lines of code, we eliminated many lines of code, depending on the size of your application.

This is a much cleaner, shorter, and easier to read and maintain way,
to render your lists.

Will re-add our Event Listeners in a minute..

// Before 
  <div>
    <Person 
    name={this.state.persons[0].name}
    age={this.state.persons[0].age} />
    <Person 
    name={this.state.persons[1].name}
    age={this.state.persons[1].age} />
    <Person 
    name={this.state.persons[2].name}
    age={this.state.persons[2].age} />
    <Person 
    name={this.state.persons[3].name}
    age={this.state.persons[3].age} />
  </div>

// After
  <div>
    {this.state.persons.map(person => {
      return <Person 
        name={person.name}
        age={person.age} />
    })}
  </div>

The above example illustrates the advantages and benefits of using the "map()" method.
Mapping an Array, into an Array with JSX Elements.
This is the common pattern for outputing lists in React.

"Lists and State"

Now let's add in a way to "Delete" a person for our array.

deletePersonHandler = () => {
  
}

Then, We can add a click prop to to component.

click={this.deletePersonHandler}

Remember, you can name "click" whatever you'd prefer.

Now that our Handler is being referenced to our component,
we can now access that prop from inside the component.

Adding an onClick as an attribute to the paragraph tag,
we can pass our handler using props.

onClick={props.click}
// Remember to add props into the arguements of your "Functional" Component"

The "Map()" method, allows gives us access to another arguement for our array, "index".

{this.state.persons.map((person, index) => {
  return < Person 
    click={this.deletePersonHandler}
    name={person.name}
    age={person.age} />
})}

// Remember, if you have more than one arguement, you have to wrap them in parenthesis ()

Now you'll want to pass the "index" to the delete handler.

click={() => this.deletePersonHandler(index)}

By turning the delete handler into an anonymouse function, 
you now open up the ability to pass arguements, in this case, "index".

Continue by passing the "index" up to the "deletePersonHandler" naming it "personIndex".

Inside your Handler, now grab all the persons into a variable.

togglePersonHandler = (personIndex) => {
  const persons = this.state.persons;
  persons.splice(personIndex, 1);
  this.setState({persons: persons})
}

Taking your "persons", adding a "splice()" method to the index,
and removing 1 index.

then setting the state to "persons:persons".

This approach however has a flaw. When you click on the paragraph tags,
the component does get removed.

However, we are unable to get the list back without refreshing the page.


"Updating State Immutably"

The flaw in our above approach of removing a person by index from the state,
is that, in JavaScript, "Objects and Array" are "Reference" types.

So when you are getting "persons" from the "State", you are actually getting a "Pointer",
to the original "Persons" object or original state, managed by React.

If you then "Splice()" it, you already mutated the original data.
While it does work without throwing an error, it is "NOT" the correct way to do this.
This way can lead to unpredictable apps, and a definate bad practice.


A good practice, would be to make a copy of your persons array, or state.
A simple way to do this, is by calling the "slice()" method.
"slice()" without arguements simply copies the array and returns a new one.

deletePersonHandler = () => {
  const persons = this.state.persons.slice();
  persons.splice(personIndex, 1);
  this.setState({persons:persons});
}

Now, by adding in a "splice()" method, you are no longer manipulating the original state,
but manipulating a COPY of the current state. Then, with setState, "merging" the two States.

This way allows you to manipulate or change state, without ever changing the ORIGINAL state.

An even better way to achieve this is by using the "Spread Operator" (...).

"splice()" only works on arrays, whereas the spread operator works on everything iterable(?).


"Lists and Keys"
A "key prop" is an important "property" we should add, when rendering lists of data.

This is why React gives us a warning to do so.

The "key prop" is a default property, React expects to find,
On an element, no matter if it's a custom Component or a default HTML element,
Once you render through a list.

e.g. By "Mapping" an Array into JSX. // this.state.persons.map()

The "key" property also helps React update, efficiently.

React has a "Virtual DOM", where it compares what it would render now,
if it were to call the render method now, to the previous DOM.

It basically does a comparison of the Future to the Past.

For "Lists" it needs to find out which elements changed.

For lists, it would just re-render the whole list.
That is why the "Key" prop is so important.

It allows React to keep track of individual elements in a list,
so that is has a clear property, that it can compare between the two elements.
To find out which elements changed and which didn't.
That way, React will only re-render elements that DID change,
and not the entire list.

Generally, your data should already have it's own unique ID,
Typically generated as a unique ID from the database.

If not, give each element it's own unique id.
Each element should ALWAYS have it's own ID.


"Wrap Up"

We should output content conditionally, by using JavaScript.
The same for Lists, everything is JavaScript.
You can do it with Ternary Expressions,
but a better way is to create variables,
which you output in your JSX, and use if statements to render content conditionally.

If you want to render a list, use the map() method.
Should add a key prop.


" Assignment 2 "

"Step 1": Create a new Input field, inside the Root/App Component,
with a change listener, that outputs the length of the entered text below it.

Adding an Event Listener, Using the User Input, Rendering it,
and you probably need State.

"Step 2": Create a new component, e.g. "Validation Component",
which receives the text length, as a prop.

e.g. The length of the text the user enters. You should probably,
store this length in the state aswell. You can get it with the .length() property,
executed on the entered text.

// JavaScript Strings are basically Arrays.
// You can use Array Methods on them.

"Step 3": Work inside the "Validation Component", and not only store the "length" property,
but EITHER output "Text too short" or "Text long enough".
Choose any cutoff points you'd like. e.g. Minimum 5, Maximum 12.
You won't need to manage the state in the validation component to achieve this.

Get the text length as a prop,
then conditionally render one of the two texts,
depending on the length.
Inside a paragraph, inside the validatio component.

"Step 4": Create a new component, the "char" component.
Style it as an inline box. Some example styling you could use would be,
display: 'inline block;
padding: '16px';
textAlign: 'center';
margin: '16px';
border: '1px solid black';
backgroundColor: 'whatever you want';

Then, render a list of these "char" components,
it should be 1 "char" component, per character, the user entered.

Then pass this character, as a prop. 
So basically, display the text, as a collection of boxes, close enough
Make sure to render this list of char components, in the app component.
Not in the validation component.


You can convert a string into a real array of text,
you can call the split() method, and pass an empty string.
You will split it into an array of characters. 
You can then call map() on that.

You can then "splice()" something, on the converted array,
and then "join()", with an empty string as an input, 
you can then to turn it back into text.

-------------------------------------------------------

// INSTRUCTOR EXAMPLE
import React, { Component } from 'react';
import Validation from './Validation/Validation;
import Char from './Char/Char;

class App extends Component {
  state = {
    userInput: ''
  }

  inputChangedHandler= (event) => {
    this.setState({userInput: event.target.value})
  }

  deleteCharHandler = ( index) => {
    const text = this.state.userInput.split('');
    text.splice(index, 1);
    const updatedText = text.join('');
    this.setState({userInput: updatedText});
  }

  render() {
    const charList = this.state.userInput.split('').map((ch, index) => {
      return <Char 
        character={ch} 
        key={index} 
        clicked={() => this.deleteCharHandler(index)} />
    })

    return (
      <div className="App">
      <input type="text" 
      onChange={this.inputChangedHandler} 
      value={this.state.userInput} />
      <p>{this.state.userInput}</p>
      <Validation inputLength={this.state.userInput.length}/>
      {charList}
      </div>
    )
  }
}


// VALIDATION COMPONENT

import React from 'react';

const validation = ( props ) => {

  let validationMessage = 'Text long enough';

  if (props.inputLength <=) {
    validationMessage = 'Text too short';
  }

  return (
      <div>
        <p>{validationMessage}</p> 
      </div>
  );
};

export default validation;


----------------------------------------------------

// CHAR COMPONENT

import React from 'react';

const char = (props) => {
    const style = {
      display: 'inline-block',
      padding: '16px',
      margin:  '16px',
      border: '1px solid black',
      textAlign: 'center'
    };

  return (
      <div style={style} onClick={props.clicked}>
          {props.character}
      </div>
  )
};

export default char;

-----------------------------------------------------

"Module Introduction"

Styling React Components 

Look at how you can dynamically adjust styles, or class names.
Also learn how to work around the restrictions of either,
  - Using Inline Styles (Scoped Styles)
      Limitations: Unable to use media queries or pseudo selectors.

  - Using CSS files, and having global styles.


"Setting Styles Dynamically"

It is ALL JavaScript, you can manipulate the style object with anything you want,
Then when you bind it to a property, it will apply it.
No matter HOW you edited it.

"Setting Class Names Dynamically"

One way you can dynamically style your elements is,

Create some new styles and classes in the global App.css stylesheet.
e.g.

.red {
  color: red;
}

.bold {
  font-weight: bold;
}


You can then, create a new variable, assigned to an array,
that holds your new class names.

let classes = ['red', 'bold'].join(' ');

This is one way you can grab multiple class names and assign them.
Using the join() method on the array of class names,
it will join the 2 together, seperating them by a space.
// bold red

To add some dynamics to our styles,
we could write our classes in an if statement,
and push() a specific className into the array depending on the conditions.

Then, adding the array, with the join() method to the className of an element.

---------------------------------------------

const classes = [];
if (this.state.persons.length <= 2) {
  classes.push('red'); // classes = ['red']
}
if (this.state.persons.length <= 1) {
  classes.push('bold'); // classes = ['red', 'bold']
}


<p className={classes.join(' ')}> Dynamic Styles! </p>

-----------------------------------------------


"Adding and using Radium"

Radium allows us to use/add Media Queries and Pseudo Selectors,
to our Inline Styles.

npm install --save radium

To use Radium, simply import it into the file you'll be using it with.
Then, add it to your export statement at the bottom of the file.

export default Radium(App);

This is called a "Higher Order Component".
Now you can use "Radium" on both your "Class" components,
aswell as your "Functional" components.

If your seperate "Functional" component files,
you can add the same "import" and "export" statements,
to gain access to "Radium" features.

const style = {
  backgroundColor: 'green',
  color: 'white',
  font: 'inherit',
  border: '1px solid blue',
  padding: '8px',
  cursor: 'pointer',
  ':hover': {
    backgroundColor: 'lightgreen',
    color: 'black'
  }
};


You can add in your Radium elements, just like normal properties.
a "Pseudo" element, like "Hover" does however,
need to exist between a pair of quotations.
As a "Colon" (:), is not a proper JavaScript element.

You also can add these styles inside of your components.

style[':hover'] = {
  backgroundColor: 'salmon',
  color: 'black'
}

Pseudo selectors not only need to be wrapped in quotations,
but also put inside a pair of square brackets like an array.
Prefaced by a "style" property.

"Radium" isn't only good for Pseudo Selectors, 
it allows allows you to use "Media Queries".


"MEDIA QUERIES"

const style = {
    '@media (min-width: 500px)': {
      width: '450px'
    }
  }

  <div style={style}> </div>


  In order for "Media Queries", "Keyframes", etc.
  To work properly, you MUST wrap your entire application,
  in a <StyleRoot> </StyleRoot> component.

  Remember to import StyleRoot with your Radium.

  import Radium, { StyleRoot } from 'radium;



  "Introducing Styled Components"

  Another more popular library other than "Radium",
  is "Styled Components".

  What is "Styled Components"?

  This library is all about, styling components,
  and making that very simple.

//  styled-components.com

Install: // npm install -save styled-components
import styled from 'styled-components'

Example:
const Button = styled.button``

The two backticks are actually JavaScript. It is called,
"Tagged Templates".

"Tagged Templates" have nothing to do with "React" specifically,
but it is available in Vanilla JavaScript.

The way the above syntax works is,

It is actually a Function call. 
"Button" would be the Function, or Method,
on the styled object.

Instead of parantheses, which you would typically use to insert function arguments,
you use 2 backticks "``".

The backticks receive text as "arguments". Which is then passed into the "Button" method,
in a special way.

Inside these backticks, is where you'll write your styles.

Example: 

styled.div`
  margin: 10px;
  padding: 10px;
  border: 1px solid black;
`

Inside the backticks, you can write just normal CSS properties,
but you must create components for your elements. Otherwise,
your elements will now work. The code will break.

e.g.

styled.div`
  some Styles
`

</div>

This, does not work, obviously. 
The solution to this is creating a new component, for this Div,
and then wrapping your elements with the new div component.

const StyledDiv = styled.div`
    // some styles here
`
Now you can use it to wrap your elements like so,

<StyledDiv>
// JSX elements
</StyledDiv>


"IMPORTANT"

EVERY  method provided by the "Styled" object, returns a React Component.

Above, we are "not" creating a React Component where we get props,
and return some JSX, because we are already returning a component.

So instead of creating a function, or functional component,
we just store the result of the "styled.div``" method call,
inside our StyledDiv variable.


"STYLED COMPONENTS CONT.."




























