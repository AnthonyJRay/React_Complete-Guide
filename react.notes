What is React?
"A JavaScript library for building User Interfaces"

Why use React?
"UI State becomes difficult to handle with Vanilla JavaScript."
"Focus on Business Logic, not on preventing your App from breaking."
"Huge Ecosystem, Active Community, High Performance."

React Alternative
"Angular" "React" "Vue"
"jQuery is more about traversing the dom."

Single Page Applications vs Multipage Applications
"SPA - Only ONE HTML page, Content is re-redered on Client"
"MPA - Multiple HTML Pages, Content is redendered on server"
"If you manage the entire page with JavaScript, you never have to go back to the server to reload the page"
"With SPA, you typically only need ONE ReactDOM.render() call."
"With MPA, You need a ReactDOM.render() call per each component."


Course Outline
--------------
1.  Getting Started
2.  The Basics
3.  Debugging
4.  Styling Components
5.  Components Deep Dive
6.  HTTP Requests
7.  Routing
8.  Forms & Validation
9.  Redux
10. Authentication
11. Intro to Testing
12. Deployment
13. Bonus - Animations, Next Steps, Webpack, NextJS, Etc.


-Getting Started-
-------------------

-- ES6 Refresher

"let - variable values"
"const - constant value"

"arrow functions"
function printMyName(name) {
  console.log(name);
}
printMyName('Anthony');

"As an arrow function"
const printMyName = name => console.log(name);
printMyName('Anthony');


"Exports and Imports"
Inside a JavaScript file, we can import content from another file.

"Import Syntax Examples"
import person from './person.js'

-or-

import{baseData} from './utility'
import{clean} from './utility'

baseData and/or clean imports is for targetting specific data.
It is also known as "named exports".
If using a named export, you must import using the exact name you are exporting.
If using a default export, you can name them whatever you like as long as the file path is correct.


-React Classes-
---------

A class is created with the "class" keyword.
A class can have both "properties" and "methods"
"Properties" are like variables within classes.
"Methods" are like functions within classes.

Classes are kind of like Constructory functions.
Create JavaScript objects with classes with blueprints.
Classes support inheritence.

When creating a class, if it contains any properties,
you must put them inside of a "Constructor Method"

class Example {
  constructor() {
    this.sample = 'Sample';
  }
}


When extending a class to another, you must include the
special "super();" keyword to inherit the classes properties.

class ExampleTwo extends Example {
  constructor() {
    super();
    this.sample2 = 'Another Sample';
  }
}

The "super()" keyword goes inside the constructor function.

When you extend a class to another classes properties, 
you can still hard code in the extended classes properties and override
the inherited properties. Not best practice, or a good habit.

Classes are just "blueprints" for JavaScript "objects" and are 
very comparable to constructor functions, and inheritence is comparable to prototypes.


-Classes Properties Methods-

"Properties" are like "variables attached to classes and objects"
"Methods" are like "functions attached to classes and objects"


-NextJS syntax-
---------------

"Properties"
-ES6-
constructor() {
  this.myProperty = 'value'
}

-ES7-
myProperty = 'value'

When writing your property directly into a class without
the "constructor" function, it will still be compiled behind the scenes into one.
The ES7 syntax allows writing properties easier.


"Methods"
-ES6-
myMethod() {

}

-ES7-
myMethod = () => {

}

Same goes for methods. Although it looks as if you are just,
taking a typical function and writing it as an arrow function(?)

The advantage you have with this syntax is, when you use an arrow function,
you don't have any problems with the "this" keyword.


-The Spread and Rest Operators-
-------------------------------
"..."

The "..." syntax is either a Spread or Rest operator depending on how we use it.

-Spread-
"Used in front of an array"

-Examples-
const newArray = [...oldArray,1,2]

"Also can be used with Objects"
const newObject = {...oldObject, newProp:5}

Used to split up array elements OR object properties.

Spread is used to take an "array" and extract the values within it,
creating a new "array" with copies of those values, and add in new values.

Must use the "spread operator" to make a "copy" of an array to manipulate it,
because in React, state is immutable and cannot be changed.


-Rest-
"Used in a function arguements list"

Used to "merge" a list of "function arguements"
into an array.

-Examples-
function sortArgs(...args) {
  return args.sort()
}



-Destructuring-

"Destructuring" allows you to easily extract array elements,
or object properties and store them in variables.

-Array Destructuring-
[a,b] = ['Hello, 'Max']
console.log(a) // Hello
console.log(b) // Max

Using the syntax above, we can assign the values "Hello" and "Max" to variables.
It looks like we are creating a new Array but we are not, we are assigning variables to an arrays values.

Another example of "Array Destructuring might look something like,

const numbers = [1, 2, 3];
[num1, , num3] = numbers;
console.log(num1, num3); // 1, 3

You can pull are items in varied orders by using a space in one values position to skip it.


-Object Destructuring-
{name} = {name:'Max', age:28}
console.log(name) // Max
console.log(age) // undefined

In "Array Destructuring", the order defines which property we take.
Whereas in "Object Destructuring" it's the property name.

So the syntax: "{name}" targets the name property in the above object, and pulls out it's value.
This is why "age" returns undefined, as we are only pulling the "name" property out of the object.


-Reference and Primitive Types refresher-

-Primitive types-
"Numbers, Strings, Booleans" these are "Primitive Types"
Whenever you reassign or store a variable inside another variable, it will copy the value.

-Reference Types-
"Objects, Arrays" these are "Reference Types"
When you reassign an object variable to another variable, it still stores it's values,
but it does "NOT" copy it's values.

ObjectA will be stored inside memory, whereas object B will store a "POINTER", that is pointing to object "A"

-Examples-
------------------------------
const person = {
  name: "Anthony"
};

const secondPerson = person;

person.name = "Vincent";

console.log(secondPerson;) // name: "Vincent"
------------------------------

This is important in React as it can cause unexpected behaviors,
if you "copy" arrays and objects like this, because you may manipulate one object in one place,
and accidently manipulate another usage of the same object somewhere else in the application.

This is where the "spread operator" becomes handy and important,
because with the "spread operator" you are literally making a new "copy",
without manipulating the original values.

------------------------------
const person = {
  name: 'Anthony'
};

const secondPerson = {
  ...person;
}

person.name = 'Vincent';

console.log(secondPerson); // name: "Anthony"
-------------------------------

The "name" property remains unchanged, as "secondPerson" it it's own copy first, of the original values.
instead of storing a "pointer", pointing to the "location" of the object.

It's important to remember, "Objects" and "Arrays" are "Reference Types".
And when you reassign them, you are copying the "Pointer" not the value.


-Array Functions Refresher-

Each one of these array functions take an arrow function as a parameter.
The function then gets executed on each item in the array as it is iterated.

-Examples-
-------------------
const numbers = [1, 2, 3];

const doubleNumArray = numbers.map((num) => {
  return num*2;
});

console.log(numbers); // [1, 2, 3]
console.log(doubleNumArray) // [2, 4, 6]


-REACT BASICS-

"Build Workflow"
----------------

Why?
"Optimize Code"
  When we build and deploy our app, we want our code to be optimized and as small as possible.
  This in turn boosts the performance of our app.

"Next-Gen JavaScript"
  Makes writing our code much easier and more efficient.
  Also is the standard for writing React applications.
  The result is a codebase that is "leaner, easier to read, faster, and less error prone"

"Be more productive"
  CSS auto prefixing, helps with adding cross-browser support code to our CSS.

How?
  "Dependency Management Tool"
    NPM, Node Package Manager.
    NPM is standard.

  "Bundler"
    Webpack
    Bundle together modules or split up files.

  "Compiler"
    Babel + Presets
      Compile your ES6/ES7 JavaScript code down for browser support.

  "Development Server"


-Create React App-
To install, you install it "globally" with "npm"
Must have "Node.js" installed.

"npm install -g create-react-app"

To start a React application, run "create-react-app" followed by the app "name"

"create-react-app myReactApp"

Once the "react app" is made, "cd" into that file and run "npm start" to start the "development server".

// Must leave the Terminal tab running the Local Dev Server open-


-Understanding React folder Structure-


