What is React?
"A JavaScript library for building User Interfaces"

Why use React?
"UI State becomes difficult to handle with Vanilla JavaScript."
"Focus on Business Logic, not on preventing your App from breaking."
"Huge Ecosystem, Active Community, High Performance."

React Alternative
"Angular" "React" "Vue"
"jQuery is more about traversing the dom."

Single Page Applications vs Multipage Applications
"SPA - Only ONE HTML page, Content is re-redered on Client"
"MPA - Multiple HTML Pages, Content is redendered on server"
"If you manage the entire page with JavaScript, you never have to go back to the server to reload the page"
"With SPA, you typically only need ONE ReactDOM.render() call."
"With MPA, You need a ReactDOM.render() call per each component."


Course Outline
--------------
1.  Getting Started
2.  The Basics
3.  Debugging
4.  Styling Components
5.  Components Deep Dive
6.  HTTP Requests
7.  Routing
8.  Forms & Validation
9.  Redux
10. Authentication
11. Intro to Testing
12. Deployment
13. Bonus - Animations, Next Steps, Webpack, NextJS, Etc.


-Getting Started-
-------------------

-- ES6 Refresher

"let - variable values"
"const - constant value"

"arrow functions"
function printMyName(name) {
  console.log(name);
}
printMyName('Anthony');

"As an arrow function"
const printMyName = name => console.log(name);
printMyName('Anthony');


"Exports and Imports"
Inside a JavaScript file, we can import content from another file.

"Import Syntax Examples"
import person from './person.js'

-or-

import{baseData} from './utility'
import{clean} from './utility'

baseData and/or clean imports is for targetting specific data.
It is also known as "named exports".
If using a named export, you must import using the exact name you are exporting.
If using a default export, you can name them whatever you like as long as the file path is correct.


-React Classes-
---------

A class is created with the "class" keyword.
A class can have both "properties" and "methods"
"Properties" are like variables within classes.
"Methods" are like functions within classes.

Classes are kind of like Constructory functions.
Create JavaScript objects with classes with blueprints.
Classes support inheritence.

When creating a class, if it contains any properties,
you must put them inside of a "Constructor Method"

class Example {
  constructor() {
    this.sample = 'Sample';
  }
}


When extending a class to another, you must include the
special "super();" keyword to inherit the classes properties.

class ExampleTwo extends Example {
  constructor() {
    super();
    this.sample2 = 'Another Sample';
  }
}

The "super()" keyword goes inside the constructor function.

When you extend a class to another classes properties, 
you can still hard code in the extended classes properties and override
the inherited properties. Not best practice, or a good habit.

Classes are just "blueprints" for JavaScript "objects" and are 
very comparable to constructor functions, and inheritence is comparable to prototypes.


-Classes Properties Methods-

"Properties" are like "variables attached to classes and objects"
"Methods" are like "functions attached to classes and objects"


-NextJS syntax-
---------------

"Properties"
-ES6-
constructor() {
  this.myProperty = 'value'
}

-ES7-
myProperty = 'value'

When writing your property directly into a class without
the "constructor" function, it will still be compiled behind the scenes into one.
The ES7 syntax allows writing properties easier.


"Methods"
-ES6-
myMethod() {

}

-ES7-
myMethod = () => {

}

Same goes for methods. Although it looks as if you are just,
taking a typical function and writing it as an arrow function(?)

The advantage you have with this syntax is, when you use an arrow function,
you don't have any problems with the "this" keyword.


-The Spread and Rest Operators-
-------------------------------
"..."

The "..." syntax is either a Spread or Rest operator depending on how we use it.

-Spread-
"Used in front of an array"

-Examples-
const newArray = [...oldArray,1,2]

"Also can be used with Objects"
const newObject = {...oldObject, newProp:5}

Used to split up array elements OR object properties.

Spread is used to take an "array" and extract the values within it,
creating a new "array" with copies of those values, and add in new values.

Must use the "spread operator" to make a "copy" of an array to manipulate it,
because in React, state is immutable and cannot be changed.


-Rest-
"Used in a function arguements list"

Used to "merge" a list of "function arguements"
into an array.

-Examples-
function sortArgs(...args) {
  return args.sort()
}



-Destructuring-

"Destructuring" allows you to easily extract array elements,
or object properties and store them in variables.

-Array Destructuring-
[a,b] = ['Hello, 'Max']
console.log(a) // Hello
console.log(b) // Max

Using the syntax above, we can assign the values "Hello" and "Max" to variables.
It looks like we are creating a new Array but we are not, we are assigning variables to an arrays values.

Another example of "Array Destructuring might look something like,

const numbers = [1, 2, 3];
[num1, , num3] = numbers;
console.log(num1, num3); // 1, 3

You can pull are items in varied orders by using a space in one values position to skip it.


-Object Destructuring-
{name} = {name:'Max', age:28}
console.log(name) // Max
console.log(age) // undefined

In "Array Destructuring", the order defines which property we take.
Whereas in "Object Destructuring" it's the property name.

So the syntax: "{name}" targets the name property in the above object, and pulls out it's value.
This is why "age" returns undefined, as we are only pulling the "name" property out of the object.


-Reference and Primitive Types refresher-

-Primitive types-
"Numbers, Strings, Booleans" these are "Primitive Types"
Whenever you reassign or store a variable inside another variable, it will copy the value.

-Reference Types-
"Objects, Arrays" these are "Reference Types"
When you reassign an object variable to another variable, it still stores it's values,
but it does "NOT" copy it's values.

ObjectA will be stored inside memory, whereas object B will store a "POINTER", that is pointing to object "A"

-Examples-
------------------------------
const person = {
  name: "Anthony"
};

const secondPerson = person;

person.name = "Vincent";

console.log(secondPerson;) // name: "Vincent"
------------------------------

This is important in React as it can cause unexpected behaviors,
if you "copy" arrays and objects like this, because you may manipulate one object in one place,
and accidently manipulate another usage of the same object somewhere else in the application.

This is where the "spread operator" becomes handy and important,
because with the "spread operator" you are literally making a new "copy",
without manipulating the original values.

------------------------------
const person = {
  name: 'Anthony'
};

const secondPerson = {
  ...person;
}

person.name = 'Vincent';

console.log(secondPerson); // name: "Anthony"
-------------------------------

The "name" property remains unchanged, as "secondPerson" it it's own copy first, of the original values.
instead of storing a "pointer", pointing to the "location" of the object.

It's important to remember, "Objects" and "Arrays" are "Reference Types".
And when you reassign them, you are copying the "Pointer" not the value.


-Array Functions Refresher-

Each one of these array functions take an arrow function as a parameter.
The function then gets executed on each item in the array as it is iterated.

-Examples-
-------------------
const numbers = [1, 2, 3];

const doubleNumArray = numbers.map((num) => {
  return num*2;
});

console.log(numbers); // [1, 2, 3]
console.log(doubleNumArray) // [2, 4, 6]


-REACT BASICS-

"Build Workflow"
----------------

Why?
"Optimize Code"
  When we build and deploy our app, we want our code to be optimized and as small as possible.
  This in turn boosts the performance of our app.

"Next-Gen JavaScript"
  Makes writing our code much easier and more efficient.
  Also is the standard for writing React applications.
  The result is a codebase that is "leaner, easier to read, faster, and less error prone"

"Be more productive"
  CSS auto prefixing, helps with adding cross-browser support code to our CSS.

How?
  "Dependency Management Tool"
    NPM, Node Package Manager.
    NPM is standard.

  "Bundler"
    Webpack
    Bundle together modules or split up files.

  "Compiler"
    Babel + Presets
      Compile your ES6/ES7 JavaScript code down for browser support.

  "Development Server"


-Create React App-
To install, you install it "globally" with "npm"
Must have "Node.js" installed.

"npm install -g create-react-app"

To start a React application, run "create-react-app" followed by the app "name"

"create-react-app myReactApp"

Once the "react app" is made, "cd" into that file and run "npm start" to start the "development server".

// Must leave the Terminal tab running the Local Dev Server open-


-Understanding React folder Structure-

Inside the root folder is the package.json file which shows all of your app dependencies.
It also has scripts, which can be run using NPM.

The public folder, is the folder that gets served by the web server.
It only holds the files we can edit.
The script files are edited in the "src" folder.
In the public folder is a single "index.html" This is the only html file we will use.
You will never create additional HTML files, unless you are working on a Multi-Page Application.
In which case will require a seperate type of build tools.

The src folder is where we write our actual react app.

Included is an image file we can remove.
There is also an "app.css" file, where you can remove all the global styling in it.
Included as well is an "index.css" file with a global reset styling that can be left there.
The "app.test.js" file allows us to create "Unit Testing"

In the "app.js" file, there is an "App" component.
This is where we will include all of our other components,
building our app through this one "app" compoenent.

You can create many components, and render them individually elsewhere, but it is "not best practice"

In the "App" component, all other components get nested into each other to build out your app.

-Component Structure-

The way to create a component is to use the "class" syntax,
followed by the component "name", and optionally you can add the extends keyword,
and inherit other properties from other components.
In the included App.js file, there is an "App" component.

class App extends Component {

}

The "Class" keyword initializes the class, or component,
Follow by the name of the component, in this case "App"
and it also is extending, or inheriting properties from "Component"
"Component" is a an object, or class, that is being "IMPORTED" from the "react library"

// There are OTHER ways to create components
// Will learn that later on..

The "App" component has ONE method, the "render()" method.
It NEEDS to have that, because react will call this method, to render something to the screen.

There's one important job, every react component HAS to do...

// It MUST return some sort of HTML code
// So that it can be rendered to the DOM
// And obviously to the screen

// ALL COMPONENTS MUST DO THIS

At the bottom of the file is an export set to default.

"export default App"

This export simply means, anytime this file is imported,
It is just importing the "App" component by default.

You may also encounter some files with the ".jsx" extension instead of the ".js" extension.


-Understanding JSX-

"React.createElement()" is a react method that takes at least "THREE" arguments,

1. Element we want to render to the DOM.
2. The second arguement, is the "configuration"
3. Any amount of children, or what's nested inside the element.

-Example-
---------

return React.createElement('div', null, 'h1', 'Hi, I\'m a React App!);
---------

Although, the "h1" is not being rendered as an HTML element,
Infact, it's actually being rendered as text.

If you want to create additional elements within your React.createElement()
You will need to add another createElement method like so,

return React.createElement(
  'div',
  null,
  React.createElement(
    'h1',
    null,
    'Hi, I\'m a React App!'
  );
);


As for the configuration part, where it says null,
That is where you can do things such as add a class to your HTML elements.

return React.createElement(
  'div',
  {classNam: "App"}
)

In the null space, adding curly braces, and within stating your class name, will add it to your element.

// Above is not how you want to write your components.
// Above is just a demonstration of what your JSX actually compiles to.
// It's recommended, and BEST to stick with writing with JSX syntax.
// Although JSX may look like HTML, from looking at what it compiles to above,
// It is obvious, and important to understand that it is NOT HTML. It is actually JavaScript.


-JSX Restrictions-

Even though "JSX" looks like and "HTML", and now we know that it is actually "JavaScript",
there are some words that cannot be used like in regular "HTML".

"Class" for example, is the attribute you might use to add a "class" to an "HTML" element.
But in "JavaScript" "class" is a reserved word.

Instead, in "JSX", you must use the "className" syntax to assign an "element" a "class".

-Creating a Functional Component-

When creating new folders for your new component files in the "src" folder,
it's standard practice to always start the names of those files with a uppercase, or capital.
Within that folder, should exist the corresponding js file for your component with the matching name of the folder.

-Most of the time-, the way you "should" write a "component" is as a "functional component"
The "class components" become more useful when we start learning about "State"
-For- now, most "components" should be written as a "functional component".

// In it's simplest form, a Component, is just a JavaScript function,
// That returns, some JSX.

To create a simple "Functional Component"

-Example-
-----------------------------
import React from 'react';

const person = () => {
  return <p>I'm a person!</p>
}

export default person
------------------------------

Above, is just a normal "Arrow Function" returning some "JSX".
You must remember, to "import" react at the top, so that it will compile your "JSX" into JavaScript to work.
Also, remember to export your component.

Then all you would have to do, is "import" your component in the "App.js" file, starting with a capitalized character on the import name.

"import Person from './Person/Person';"

You can leave out the file extension on your import, as the build tools will know for you.

Once imported, you can add your component a couple of ways into your render method...

<Person> </Person>
-or-
<Person />

Either syntax works. It depends on if your component is written to take in nested components.

The reason for the capitalize starting character, is becaause,
lowercase characters are reserved for HTML tags. Therefore, in order to differenciate between,
and HTML tag and a react component, component names must start with an uppercase character.


-Components and Reusable Components-

So what is the advantages of components?
"Components" are useful because we can focus our code in each file, and helps keep it more maintainable.
They can also be "reuseable" and "configurable"

-----------------------------
const person = () => {
  return <p>I'm a Person!</p>
};
-----------------------------

The component above, is currently static. Each time you use this component, the same type of information will be used.

You want your components to be "Dynamic" and to update it's information based on it's current "State"

-Simple Example-

  return <p> I'm a Person and I am {Math.floor(Math.random() *30)} years old </p>

  From the above example, you'll notice we added some JavaScript inside of our JSX.
  In order for React to read it like JavaScript instead of plain text,
  "You must wrap it in a set of curly braces"

  Inside the curly braces, you can not add classes.
  What you can add, is "short" "single-line" "JavaScript Expressions"
  You could also call a function, and that function also call some more complex functions.


-Working with Props-

For normal "HTML/JSX" elements, we can pass "Attributes" like "className"

Inside our "Component" JSX tags, we can add custom attributes called "props"
In order for your component to accept props, You must pass "Props" as an arguement.

-Understanding the Children Attribute-
"Using content that is not passed as an attribute, but passed between the opening and closing tags of a component"

"props.children"

Children is a reserved name.
It refers it any elements, between the opening and closing tag of a component.


-Understanding and Using State-

When creating "Variables" inside of a "Class", 
you don't need to use a variable keyword. Started
Such as: "Var" "Let" "Const"

This only works in Components "Extending" Components.

Where "PROPS" are set and passed from "OUTSIDE" the component,
"STATE" is managed "INSIDE" the component.

-REMEMBER-
"STATE" is only accessible from "CLASS" based components "EXTENDING" to Component.

There is a way to manage state in functional components with "React Hooks". Will cover later in course.


Although, You should use "functional components" as often as possible,
because you should use "STATE" with care.

Having in state in all of your components, can make your app run unpredictably quickly.
and can also make for an app that is hard to maintain.

We initialize "state" by assigning it a "value". 
The "value" being a "JavaScript Object".

-------------
state = {

}
-------------

The special thing about "State" is that it can be changed.
If it changes, it will let React re-render the DOM or update the DOM.


-Course Notes-

"props" and "state" are CORE concepts of React. Actually,
only changes in "props" and/or "state" trigger React to
re-render your components and potentially update the DOM
in the browser.

"Props" - Allow you to pass data from a parent (wrapping)
component to a child (embedded) component.


-Example-

---------------------------------

"AllPosts Component"

const posts = () => {
  return (
    <div>
      <Post title="My first Post" />
    </div>
  );
}

----------------------------------

Here, "title" is the custom property ("prop")
set up on the custom "Post" component. We basically replicate
the default HTML attribute behaviour we already know

eg (<input type="text">
informs the browser about how to handle that input.)

"Post Component"

------------------------------

const post = (props) => {
  return (
    <div>
      <h1>{props.title}</h1>
    </div>
  );
}

-------------------------------

The "Post" component receives the "props" argument. 
You can of course name this argument whatever you want -
it's your function definition, React doesn't care!

But React will pass one argument to your component function =>
An object, which contains all properties you set up on <Post .... />

"{props.title}" then dynamically outputs the "title" property,
of the "props" object - which is available since we set the "title" property inside "AllPosts" component(see above).


-State-

Whilst props allow you to pass data down the component tree,
(and hence trigger an UI update), "state" is used to change the component, state, from within.
Changes to state also trigger an UI update.

-Example-
---------------------------------------------

class NewPost extends Component { // state can only be accessed in class-based components!
    state = {
      counter: 1
    };

    render () { // Needs to be implemented in class-based components! Must return some JSX!
      return (
        <div>{this.state.counter}</div>
      );
    }
 }
----------------------------------------------

Here, the "NewPost" component contains "state".
Only class-based components can define and use "state".
You can also pass the "state" down to functional components,
but these then can't directly edit it.

"State" simply is a property of the component class,
you have to call it "state" though - the name isn't optional.
You can then access it via "this.state" in your class JSX code (which you return in the required "render()" method).

Whenever "state" changes, the component will re-render and reflect the new state.
The difference to "props" is, that this happens within one and the same component -
you don't receive new data ("props") from outside!


-Handling Events with Methods-

"<button onClick={}></button>"

Using "onClick" you then assign as a "value",
the code you want to run, upon a click.

You can use curly braces "{}"
To then insert some "Dynamic" code.

-Typically- you'll want to "execute" a "function",
of your "class". A so-called "Method".

There is a convention, to give it's name like the following -

"switchNameHandler"

The "switchName" part is up to you,
but you typically use "Handler" at the end.
To indicate, that this is a "method" you're not "actively"
calling... but you're assigning as an "Event Handler"

It is not required to follow this pattern, 
but it is "Good Practice" to follow this naming convention.
eg "buttonNameHandler", "clickMeHandler".

Now, you'll want to turn "switchNameHandler" into a function.

-----------------------------
switchNameHandler = () => {

}
-----------------------------

If we assign a "function" to the "switchNameHandler",
it basically becomes a method.

Because it still exists inside the "class-based component",
it is kind of a "Property"

But a "property" that holds a "function" for which can be "executed".

From here, inside the "switchNameHandler" arrow function,
you can now "edit" your "state".


"<button onClick={this.switchNameHandler}> I'm a Switch! </button>

To add the "switchNameHandler" to your button, simply add
the "this" keyword, followed by the name of the "handler".

Remember, "this" is just pointing to our "class" component.

Also, don't add the parenthesis "()" to the end of the "handler",
or else it will run the function "immediately" upon rendering.

There are many other "events" you can listen for besides "onClick"
Check the React documentation for more such as,

"onCopy"
"onPaste"
"onCut"


-Manipulating the State-

Now with the "Handler" in place, we can start to manipulate the state.

-------------------------------------------
switchNameHandler = () => {
  this.state.persons[0].name = "New Name";
}
-------------------------------------------
// You CANNOT directly manipulate the state like this!

Instead, use a special "Method" React gives you.

-setState-

The "setState" method, comes from the React library,
through extending the class component to "Component"

-------------------------------------------
switchNameHandler = ({}) => {
  this.setState()
}
-------------------------------------------

This is a "method" that allows us to "update" the "state"
property.

That way, React will know about this "update", 
and will update the "DOM".

"setState" takes an "Object" as an arguement, and
it will "merge" whatever we define inside the "Object",
with our existing "state".

There aren't many ways, that lead React to "update" the DOM,
changing "State" and "Props".

Now, with "Props", you can use "State" in "Functional" components,
but you will need to use "React Hooks" to achieve this.


-Using useState Hook for State Manipulation-

In the release of version 16.8, "React Hooks" were released.
"React Hooks" allow us to manage "State" in "Functional" components.

// Even though it is now possible to manage State in -
// Functional Componenents, it is still best to stick with
// the traditional convention of managing state in your
// Class-based components.

Most likely, if you are working on a React team, you will be,
working with an application that uses the traditional syntax.
"React Hooks" is still new, and hasn't yet become the
traditional method for managing state.

"React Hooks" is really just a list of "Functions" of which, 
you can use in your "Functional Components".

To use "React Hooks" you must "import" them, just like "Components".

To import "React Hooks" you use the "useState" keyword.

"import React, { useState }, from 'react';"

All "React Hooks" start with the "useState" syntax.

"useState" is the MOST important "React Hook"
"useState" allows us to use state, in a "functional component".

To use "useState", you call it, like a function.
Into the "useState" function parameters, you pass in,
the "initial state".

-Example-
// Taking our "State" from our class-based component from earlier
// and turning into a React Hook

class
state = {
  persons: [
    { name: 'Anthony', age: 30 },
    { name: 'Debra', age: 29 },
    { name: 'Vincent', age: 1 },
    { name: 'Max', age: 28 },
    { name: 'Manu', age: 29 }
  ]
}

-to-

const App = props => {
 const stateArr = useState({
    persons: [
      { name: 'Anthony', age: 30 },
      { name: 'Debra', age: 29 },
      { name: 'Vincent', age: 1 },
      { name: 'Max', age: 28 },
      { name: 'Manu', age: 29 }
    ]
  });
}

"What exactly does useState do?"

"useState" returns and "array" with exactly "two" elements,
and "ALWAYS" two elements.

- The "first" thing we get back will always be our "CURRENT" state,
the "CURRENT" "initial state", as well as the "updated" changes, if there are any.

- The "second" element we get back is a "function" that allows us to -
"update" our "state". This allows "React" to be aware of it, and -
"re-render" the "component".

Which is the idea, and which is the same thing that happens with "State' -
in "Class-Based Components".

-Array Destructuring-

Adding a pair of square brackets "[]" to the "left" side of the "equal sign",
which allows you to pull elements out of the array you get back from the "equal sign"

Now you just replace "this.state" with the "personsState", because,
we are using a "functional" component instead of a class-based component,
the "this" keyword will not work.
"This" only pertains to a "class-based component".

When using "React Hooks", the "function" we get back as our "second element",
with "useState" that allows us to update or modify our "state",
Does "NOT" "merge" the "new state" with the "old state".
Instead, it "overwrites" the "old state" with the "new state".

Any data from the old state you want to keep, must be manually included.

The better, more elegant way to manually add existing state properties,
is to use "useState" "multiple" times.

Where as in "Class-Based" components, you only have "one" state property,
and "this.setState" automatically "merges" changes with the old state.


-Stateless vs Stateful Components-


